<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Momentum Tracker</title>
  <meta name="theme-color" content="#0b0b0b" />
  <style>
    :root { --bg:#0b0b0b; --card:#131313; --muted:#a8a8a8; --text:#f2f2f2; --line:#242424; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap{ max-width:720px; margin:0 auto; padding:18px; }
    header{ display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:14px; }
    h1{ font-size:18px; margin:0; letter-spacing:.2px; }
    .date{ color:var(--muted); font-size:13px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:16px; padding:14px; margin:12px 0; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .sub{ color:var(--muted); font-size:13px; margin-top:4px; }
    .secTitle{ font-size:13px; letter-spacing:.12em; color:var(--muted); text-transform:uppercase; margin:0 0 10px 0; }
    .task{ display:flex; align-items:flex-start; gap:10px; padding:10px 8px; border-radius:12px; border:1px solid transparent; }
    .task:hover{ border-color: var(--line); }
    input[type="checkbox"]{ width:20px; height:20px; margin-top:2px; }
    .task label{ flex:1; cursor:pointer; }
    .pill{ font-size:12px; padding:4px 8px; border:1px solid var(--line); border-radius:999px; color:var(--muted); }
    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      background:#1c1c1c; color:var(--text);
      border:1px solid var(--line);
      border-radius:12px; padding:10px 12px;
      cursor:pointer; font-weight:600;
    }
    button:hover{ filter:brightness(1.1); }
    button.primary{ background:#2a2a2a; }
    textarea{
      width:100%; min-height:160px; resize:vertical;
      background:#101010; color:var(--text);
      border:1px solid var(--line);
      border-radius:12px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:12px; line-height:1.4;
    }
    .done{
      text-align:center; padding:28px 14px;
    }
    .done h2{ margin:0 0 8px 0; font-size:22px; }
    .done p{ margin:0; color:var(--muted); }
    .hr{ height:1px; background:var(--line); margin:10px 0; }
    .tiny{ font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Momentum Tracker</h1>
        <div class="date" id="dateLine"></div>
      </div>
      <div class="pill" id="streakPill">Streak: 0</div>
    </header>

    <div class="card">
      <div class="row">
        <div>
          <div style="font-weight:700" id="focusPhrase"></div>
          <div class="sub">Open twice a day: morning + evening. Tick ‚Üí it disappears.</div>
        </div>
        <div class="pill" id="anchorPill">Anchors: 0/3</div>
      </div>
    </div>

    <div id="app"></div>

    <div class="card">
    <div class="card">
  <div class="row">
    <p class="secTitle" style="margin:0">Settings</p>
    <button id="toggleSettings" class="pill">‚öôÔ∏è Open</button>
  </div>

  <div id="settingsPanel" style="display:none; margin-top:12px;">
    <div class="sub" style="margin-bottom:10px;">
      Only change this if we agree to tweak. For 7 days: don‚Äôt touch it üòÑ
    </div>

    <textarea id="settingsBox"></textarea>

    <div class="btns">
      <button class="primary" id="saveSettings">Save Settings</button>
      <button id="exportBtn">Export Data</button>
      <button id="importBtn">Import Data</button>
      <button id="resetTodayBtn">Reset Today (untick all)</button>
    </div>

    <div class="tiny" style="margin-top:10px;">
      Tip: Export once a week so you‚Äôve got a backup.
    </div>
  </div>
</div>

<script>
(() => {
  const LS_KEY = "momentum_app_v1";

  const today = () => {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
  };

  const prettyDate = (iso) => {
    const [y,m,d] = iso.split("-").map(Number);
    const dt = new Date(y, m-1, d);
    return dt.toLocaleDateString(undefined, { weekday:"long", year:"numeric", month:"long", day:"numeric" });
  };

  const safeParse = (s, fb) => { try { const v = JSON.parse(s); return v ?? fb; } catch { return fb; } };

  const defaultSettings = {
    profile: { name: "Duncan", focusPhrase: "I do the next right action ‚Äî every day." },

    // Tick ANY 3 of these to protect streak
    anchors: [
      { id:"move_body", text:"Move body (workout OR walk/run Dumbo)" },
      { id:"personal_care", text:"Personal care routine (wash/shower, shave/trim, skincare)" },
      { id:"invite_block", text:"Invite (1 hour OR 5 numbers)" },
      { id:"admin_or_pd", text:"Admin (1 hr max) OR Personal development (30 mins)" }
    ],
    anchors_required: 3,

    sections: [
      {
        title: "Daily Anchors (streak protection)",
        info: "Tick any 3 to protect streak. Items disappear when ticked.",
        taskIds: ["move_body","personal_care","invite_block","admin_or_pd"]
      },
      {
        title: "Business",
        info: "Tick ‚Üí disappears. No numbers. No totals. Just done.",
        taskIds: [
          "follow_up_inviting",
          "post_ig_fb",
          "collate_inviting",
          "follow_up_engagement",
          "connect_coach"
        ]
      },
      {
        title: "Life & Fuel",
        info: "Keep it simple. Basics only.",
        taskIds: [
          "pre_post_breakfast",
          "lunch_dishes",
          "dinner"
        ]
      },
      {
        title: "Evening Reset",
        info: "Close the day properly.",
        taskIds: [
          "club_receipts",
          "bath",
          "pack_bag"
        ]
      }
    ],

    tasks: {
      // Anchors
      move_body: { text:"Move body (workout OR walk/run Dumbo)", type:"daily" },
      personal_care: { text:"Personal care routine (wash/shower, shave/trim, skincare)", type:"daily" },
      invite_block: { text:"Invite (1 hour OR 5 numbers)", type:"daily" },
      admin_or_pd: { text:"Admin (1 hr max) OR Personal development (30 mins)", type:"daily" },

      // Business
      follow_up_inviting: { text:"Follow up inviting activity (same day)", type:"daily" },
      post_ig_fb: { text:"Write & post Instagram + Facebook post", type:"daily" },
      collate_inviting: { text:"Collate today‚Äôs inviting activity", type:"daily" },
      follow_up_engagement: { text:"Follow up likes & comments", type:"daily" },
      connect_coach: { text:"Connect with 1 coach", type:"daily" },

      // Alternating task
      guinea_pig: { text:"üêπ Send 5 Guinea Pig invites", type:"every_other_day" },

      // Life & fuel
      pre_post_breakfast: { text:"Pre-workout drink + post-workout Herbalife breakfast", type:"daily" },
      lunch_dishes: { text:"Eat lunch + clear dishes", type:"daily" },
      dinner: { text:"Eat dinner", type:"daily" },

      // Evening
      club_receipts: { text:"Complete club receipts (check SumUp)", type:"daily" },
      bath: { text:"Bath", type:"daily" },
      pack_bag: { text:"Pack bag for tomorrow", type:"daily" }
    },

    // Alternating behaviour
    every_other_day: {
      taskId: "guinea_pig",
      // Start from TODAY by default (you can change this to any YYYY-MM-DD)
      start_date: today()
    },

    // UI/behaviour
    hideCompleted: true,
    showDoneScreen: true
  };

  const loadState = () => {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return { settings: defaultSettings, days: {} };
    const parsed = safeParse(raw, { settings: defaultSettings, days: {} });
    // Ensure defaults exist
    parsed.settings = parsed.settings || defaultSettings;
    parsed.days = parsed.days || {};
    return parsed;
  };

  const saveState = (state) => localStorage.setItem(LS_KEY, JSON.stringify(state));

  const state = loadState();
  const D = today();

  // Ensure day record exists
  if (!state.days[D]) state.days[D] = { done: {}, lastUpdated: Date.now() };

  const appEl = document.getElementById("app");
  const dateLine = document.getElementById("dateLine");
  const focusPhrase = document.getElementById("focusPhrase");
  const settingsBox = document.getElementById("settingsBox");
  const streakPill = document.getElementById("streakPill");
  const anchorPill = document.getElementById("anchorPill");

  dateLine.textContent = prettyDate(D);
  focusPhrase.textContent = state.settings?.profile?.focusPhrase || defaultSettings.profile.focusPhrase;

  const isEveryOtherDayDue = () => {
    const s = state.settings.every_other_day;
    if (!s || !s.start_date) return false;
    const start = new Date(s.start_date + "T00:00:00");
    const now = new Date(D + "T00:00:00");
    const diffDays = Math.floor((now - start) / (1000*60*60*24));
    if (diffDays < 0) return false;
    return diffDays % 2 === 0; // due on start_date, then every 2 days
  };

  const visibleTaskIdsForToday = () => {
    const ids = new Set();
    // All section tasks
    (state.settings.sections || []).forEach(sec => (sec.taskIds||[]).forEach(id => ids.add(id)));

    // Add alternating task only if due today
    const eod = state.settings.every_other_day;
    if (eod && eod.taskId && isEveryOtherDayDue()) ids.add(eod.taskId);

    return Array.from(ids);
  };

  const isDone = (taskId) => !!state.days[D].done[taskId];

  const setDone = (taskId, value) => {
    state.days[D].done[taskId] = !!value;
    state.days[D].lastUpdated = Date.now();
    saveState(state);
    render();
  };

  const anchorsStatus = () => {
    const anchors = state.settings.anchors || [];
    const required = state.settings.anchors_required ?? 3;
    const doneCount = anchors.filter(a => isDone(a.id)).length;
    return { doneCount, required };
  };

  const computeStreak = () => {
    // streak counts consecutive days (including today if protected) where anchors_done >= required
    const required = state.settings.anchors_required ?? 3;

    const keys = Object.keys(state.days).sort(); // YYYY-MM-DD sorts naturally
    if (keys.length === 0) return 0;

    // walk backwards from today
    let streak = 0;
    let cursor = new Date(D + "T00:00:00");

    const dayKey = (dt) => {
      const pad = n => String(n).padStart(2, "0");
      return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())}`;
    };

    while (true) {
      const k = dayKey(cursor);
      const rec = state.days[k];
      if (!rec) break;

      const anchors = state.settings.anchors || [];
      const done = anchors.filter(a => rec.done && rec.done[a.id]).length;

      if (done >= required) {
        streak++;
        cursor.setDate(cursor.getDate() - 1);
      } else {
        break;
      }
    }
    return streak;
  };

  const sectionCard = (title, info, taskIds) => {
    const card = document.createElement("div");
    card.className = "card";
    const t = document.createElement("p");
    t.className = "secTitle";
    t.textContent = title;
    card.appendChild(t);

    if (info) {
      const i = document.createElement("div");
      i.className = "sub";
      i.style.marginBottom = "10px";
      i.textContent = info;
      card.appendChild(i);
    }

    const list = document.createElement("div");

    const visibleIds = visibleTaskIdsForToday();
    const filtered = (taskIds || []).filter(id => visibleIds.includes(id));

    // If alternating task isn't in the section, we will render it in its own card below.
    filtered.forEach(id => {
      const taskMeta = state.settings.tasks[id];
      if (!taskMeta) return;

      if (state.settings.hideCompleted && isDone(id)) return;

      const row = document.createElement("div");
      row.className = "task";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.id = "cb_" + id;
      cb.checked = isDone(id);
      cb.addEventListener("change", () => setDone(id, cb.checked));

      const label = document.createElement("label");
      label.htmlFor = cb.id;
      label.textContent = taskMeta.text;

      row.appendChild(cb);
      row.appendChild(label);
      list.appendChild(row);
    });

    if (!list.childElementCount) {
      const empty = document.createElement("div");
      empty.className = "tiny";
      empty.textContent = "All done here ‚úÖ";
      list.appendChild(empty);
    }

    card.appendChild(list);
    return card;
  };

  const alternatingCard = () => {
    const eod = state.settings.every_other_day;
    if (!eod || !eod.taskId) return null;

    const due = isEveryOtherDayDue();
    if (!due) return null;

    const id = eod.taskId;
    const meta = state.settings.tasks[id];
    if (!meta) return null;

    // If hidden completed and done, don't show
    if (state.settings.hideCompleted && isDone(id)) return null;

    const card = document.createElement("div");
    card.className = "card";

    const t = document.createElement("p");
    t.className = "secTitle";
    t.textContent = "Every Other Day";
    card.appendChild(t);

    const sub = document.createElement("div");
    sub.className = "sub";
    sub.style.marginBottom = "10px";
    sub.textContent = "Shows only on due days. Tick ‚Üí disappears. No backlog.";
    card.appendChild(sub);

    const row = document.createElement("div");
    row.className = "task";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.id = "cb_" + id;
    cb.checked = isDone(id);
    cb.addEventListener("change", () => setDone(id, cb.checked));

    const label = document.createElement("label");
    label.htmlFor = cb.id;
    label.textContent = meta.text;

    row.appendChild(cb);
    row.appendChild(label);
    card.appendChild(row);
    return card;
  };

  const allVisibleTasksDone = () => {
    const visible = visibleTaskIdsForToday();
    // Consider only tasks that are actually part of today's UI:
    // section tasks + due alternating
    // If hideCompleted is on, completion means they disappear, but for done screen we check all tasks for the day.
    return visible.every(id => isDone(id));
  };

  const render = () => {
    appEl.innerHTML = "";

    // Update settings textarea
    settingsBox.value = JSON.stringify(state.settings, null, 2);

    // Update streak + anchors pill
    const st = computeStreak();
    streakPill.textContent = `Streak: ${st}`;

    const { doneCount, required } = anchorsStatus();
    anchorPill.textContent = `Anchors: ${Math.min(doneCount, required)}/${required}`;

    // Done screen
    if (state.settings.showDoneScreen && allVisibleTasksDone()) {
      const done = document.createElement("div");
      done.className = "card done";
      done.innerHTML = `
        <h2>Done for Today ‚úÖ</h2>
        <p>You earned rest. Open again tonight to close the day properly.</p>
        <div class="hr"></div>
        <div class="tiny">If you want extra momentum, do one small bonus‚Ä¶ then stop.</div>
      `;
      appEl.appendChild(done);
      return;
    }

    // Sections
    (state.settings.sections || []).forEach(sec => {
      appEl.appendChild(sectionCard(sec.title, sec.info, sec.taskIds));
    });

    // Alternating card (if due)
    const alt = alternatingCard();
    if (alt) appEl.appendChild(alt);
  };

  // Buttons
  document.getElementById("saveSettings").addEventListener("click", () => {
    const next = safeParse(settingsBox.value, null);
    if (!next) return alert("Settings JSON invalid. Don‚Äôt panic ‚Äî nothing saved.");
    state.settings = next;
    // refresh focus phrase
    focusPhrase.textContent = state.settings?.profile?.focusPhrase || defaultSettings.profile.focusPhrase;
    saveState(state);
    render();
    alert("Saved ‚úÖ");
  });

  document.getElementById("exportBtn").addEventListener("click", () => {
    const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `momentum-backup-${D}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  document.getElementById("importBtn").addEventListener("click", () => {
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = "application/json";
    inp.onchange = () => {
      const file = inp.files && inp.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const imported = safeParse(reader.result, null);
        if (!imported || !imported.settings || !imported.days) {
          alert("That file doesn‚Äôt look like a Momentum backup.");
          return;
        }
        localStorage.setItem(LS_KEY, JSON.stringify(imported));
        location.reload();
      };
      reader.readAsText(file);
    };
    inp.click();
  });

  document.getElementById("resetTodayBtn").addEventListener("click", () => {
    if (!confirm("Reset today? This will untick all tasks for today only.")) return;
    state.days[D].done = {};
    state.days[D].lastUpdated = Date.now();
    saveState(state);
    render();
  });

  render();
})();
</script>
</body>
</html>
